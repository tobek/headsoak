import {DataService} from '../data.service';

import {Logger} from '../utils/logger';

import {Note} from '../notes/';

import * as _ from 'lodash';
import {each as asyncEach} from 'async';


/** Information this tag generates about a specific note. */
export interface NoteSpecificDatum {
  childTag?: string, // will be displayed after tag name when shown on this note, e.g. for sentiment analysis tag called "sentiment", `val` might be "joy" and be displayed as "sentiment: joy"
  score?: any, // in addition to `val`, this will be displayed in parentheses after tag name on hover, e.g. `valHover` might be "90% confidence" and show "sentiment: joy (90% confidence)" @TODO/prog Update component and this comment: if no childTag, show score always without hover
  more?: string, // additional stuff can be displayed in the dropdown (unimplemented)
}
/** Same as `NoteSpecificDatum` but `childTag` is required: if note data is an array then each must have a child tag. */
export interface NoteSpecificDatumWithChildTag {
  childTag: string,
  score?: any,
  more?: string,
}
/** If a tag has multiple child tags on the same note, then this value can be an array. */
export type NoteSpecificData = NoteSpecificDatum | NoteSpecificDatumWithChildTag[];

export type ClassifierResult = boolean | NoteSpecificData;
export type ClassifierReturnType = ClassifierResult | Promise<ClassifierResult>;

export class Tag {
  /** By convention, IDs for user's own tags are numeric strings. These are autogenerated by TagsService when new tags are made. Other tags (previously, shared ones, currently only library tags) have other IDs like `lib--untagged`. Internal tags have IDs defined as constants in `INTERNAL_TAG_DATA`. */
  id: string;

  name = '';

  created = Date.now(); // doesn't actually get called til object is instantiated so time is correct (and of course can be overridden by data passed to constructor)
  modified = Date.now();

  docs: string[] = []; // array of note IDs

  description?: string;
  prog?: boolean; // whether it's a programmatic tag
  progFuncString?: string; // string representing programmatic ta@Tg function to be eval'd. This ccould be present even though `prog` is false, saving the function for potential future use.
  readOnly?: boolean; // @TODO/sharing handle other permissions

  share?: any; // map of recipient (shared-with) user ID to their permissions
  sharedBy?: string; // ID of user that shared this tag
  shareTooltip?: string; // text to identify sharing status to user (e.g. "you are sharing this with ___" or "___ is sharing this with you")

  readonly isLibraryTag?: boolean;

  /** Tag can store specific information on a per-note basis, indexed by note ID. */
  noteData: { [noteId: string]: NoteSpecificData } = {};

  /** Tags (currently only prog tags) can have sub tags. This index maps childTag name to list of Note IDs, so that we can both get a list of all possible child tags, and sort easily. @TODO/tags This is overall a shitty way of handling this, and I don't think multiple child tags of the same tag on one note will work very well or at all. */
  childTagDocs: { [childTagName: string]: string[] } = {};


  /** If this is set, this tag corresponds to some specially implemented feature, such as pinned or archived (and, later, private notes). Unless the user selects otherwise in settings, this tag will be hidden from everywhere (autocomplete when adding tag, tag list on notes) except searching and maybe tag browser (probably different section). */
  readonly internal?: boolean;

  /** We can't instantiate the tags here cause we have to pass in reference to DataService. So we'll let TagsService instantiate from this data. */
  static INTERNAL_TAG_DATA = {
    PINNED: {
      id: 'pin',
      name: 'pinned',
      internal: true,
    },
    ARCHIVED: {
      id: 'arch',
      name: 'archived',
      internal: true,
    },
  };
  static INTERNAL_TAG_IDS = _.map(Tag.INTERNAL_TAG_DATA, (data) => data.id);


  protected _logger: Logger;

  /** If this is a programmatic tag, this property caches the function that is run to determine if a note should have this tag. */
  private classifier?: (note: Note) => ClassifierReturnType;

  /** Properties that we save to data store */
  static DATA_PROPS = [
    'id',
    'name',
    'created',
    'modified',
    'description',
    'docs',

    'prog',
    'progFuncString',
    'isLibraryTag',
    'noteData',
    'childTagDocs',

    'internal',
    'readOnly',
    'share',
    'sharedBy',
  ];


  // @TODO how do we handle duplicate names?
  constructor(tagData: any, public dataService: DataService) {
    if (! tagData.id) {
      throw new Error('Must supply tag with id');
    }

    _.extend(this, tagData);

    this._logger = new Logger('Tag ' + this.id);

    // @TODO/old if `docs` exists, go through and add to each nut?
  }

  /** Outputs object of properties that we want to save to the data store. */
  forDataStore(): Object {
    const tagData = {};

    // @NOTE A value must be set to `null` to remove from Firebase. undefined isn't allowed.
    Tag.DATA_PROPS.forEach((prop) => {
      if (this[prop] !== undefined) {
        tagData[prop] = this[prop];
      }
    });

    return tagData;
  }

  updated(updateModified = true): void {
    if (updateModified) {
      this.modified = Date.now();
    }

    this._logger.log('Updated');

    this.dataService.digest$.emit(this);
  }

  rename(newName: string): void {
    this._logger.log('Renaming to:', newName);
    this.name = newName;
    this.updated();
  }

  /** Returns true if tag was deleted. */
  delete(noConfirm = false): boolean {
    // @TODO/modals
    if (! noConfirm && ! confirm('Are you sure you want to delete the tag "' + this.name + '"? It will be removed from all notes which have this tag, but the notes will remain.\n\nThis can\'t be undone.')) {
      return false;
    }

    this.prog = false; // so that we don't get added back by any programmatic logic when updating note while removing ourselves

    // this.docs.slice() returns a duplicate of the array which is necessary because note.removeTag will call tag.removeNoteId which will modify the array we're iterating over.
    this.docs.slice().forEach((noteId) => {
      this.dataService.notes.notes[noteId].removeTag(this, true, true);
    });

    // @TODO/rewrite/sharing
    // if (this.share && ! this.sharedBy) {
    //   // Shared tag that is shared by the current user
    //   $s.t.unshareTagWithAll(tag);
    // }

    this.dataService.tags.removeTag(this);

    this._logger.log('Deleted');

    if (this.isLibraryTag) {
      // Tag no longer lives in this.tags but is still referenced by prog tag library and could be used again, so:
      this.docs = []; // makes for cleaner update if user adds tag back in this session
      this.prog = true; // need this back!
    }

    return true;
  }

  /** @NOTE This does *not* add ourselves to the note in return. */
  addNoteId(noteId: string): void {
    this._logger.log('Adding note id', noteId);
    this.docs = _.union(this.docs, ['' + noteId]);
    this.updated();
  }
  /** @NOTE This does *not* remove ourselves from the note in return. */
  removeNoteId(noteId: string): void {
    this._logger.log('Removing note id', noteId);
    this.docs = _.without(this.docs, '' + noteId);

    // @TODO/now Test this
    const noteData = this.noteData[noteId];
    if (noteData) {
      (noteData instanceof Array ? noteData : [noteData]).forEach((noteDatum) => {
        const noteChildTag = noteDatum.childTag;
        if (noteChildTag) {
          this.childTagDocs[noteChildTag] = _.without(this.childTagDocs[noteChildTag], noteId);

          if (_.isEmpty(this.childTagDocs[noteChildTag])) {
            delete this.childTagDocs[noteChildTag];
          }
        }
      });

      delete this.noteData[noteId];
    }

    this.updated();
  }

  updateProgFuncString(newFuncString: string): void {
    delete this.classifier; // will be regenerated next time we need it
    this.progFuncString = newFuncString;
  }

  /** See if given note should be tagged by this programmatic tag. */
  runProgOnNote(note: Note, doneCb = () => {}): void {
    if (! this.prog || ! this.progFuncString) {
      this._logger.warn('Can\'t run prog tag on note - this tag is not programmatic or has no programmatic function string!', this);
      return doneCb();;
    }

    if (note.new) {
      // Unsaved empty note
      return doneCb();;
    }

    if (! this.classifier) {
      this.classifier = this.generateClassifier();
    }

    const result = this.classifier(note);

    if (result instanceof Promise) {
      result.then((result) => {
        this.handleProgResult(note, result);
        doneCb();
      })
      .catch((err) => {
        this.progTagError(err, note);
        doneCb();
      });
    }
    else {
      this.handleProgResult(note, result);
      doneCb();
    }
  }

  handleProgResult(note: Note, result: ClassifierResult) {
    if (result === true) {
      this._logger.log('User classifier returned true for note ID', note.id);
      note.addTag(this, true, true);
    }
    else if (result instanceof Array || typeof result === 'object') {
      this._logger.log('User classifier returned true for note ID', note.id, 'and noteData', result);

      (result instanceof Array ? result : [result]).forEach((noteDatum) => {
        if (noteDatum.score) {
          noteDatum.score = Math.round(noteDatum.score * 1000) / 1000;
        }

        if (noteDatum.childTag) {
          // @TODO/now Must be a better way to handle this - prob have to refactor `childTagDocs` to store this as a string and not as object key
          noteDatum.childTag = noteDatum.childTag.replace(/[\n\t]+/g, ' ').replace(/[\.#\$\/\[\]]+/g, '-'); // remove characters that Firebase doesn't allow in keys and replace with dash
          this.childTagDocs[noteDatum.childTag] = _.union(this.childTagDocs[noteDatum.childTag], [note.id]);
        }
      });

      this.noteData[note.id] = result;

      if (note.hasTag(this)) {
        // No need to add to note but we still have to update tag to save new noteData. @TODO/prog Check if noteData has changed before updating
        this.updated();
      }
      else {
        note.addTag(this, true, true);
      }
    }
    else {
      this._logger.log('User classifier returned false for note ID', note.id);
      // Eventually, this will call `this.removeNoteId` which will handle `noteData` and sub tags
      note.removeTag(this, true, true);
    }
  }

  runProgOnAllNotes(): void {
    if (! this.prog || ! this.progFuncString) {
      this._logger.warn('Can\'t run prog tag on notes - this tag is not programmatic or has no programmatic function string!', this);
      return;
    }

    this._logger.log('Running smart tag on all notes');
    this._logger.time('Ran smart tag on all notes in');
    console.groupCollapsed();

    asyncEach(this.dataService.notes.notes, this.runProgOnNote.bind(this), () => {
      // @NOTE Since these are potentially async and could take unknown amount of time to complete (maybe they should be time limited?) then other console output could get stuck in here. Not sure what to do! Not that important though since it's just for dev use.
      console.groupEnd();
      this._logger.timeEnd('Ran smart tag on all notes in');
    });
  }

  generateClassifier(): (note: Note) => ClassifierReturnType {
    var classifierFunc = new Function('note', 'api', '_', this.progFuncString); // this line excites me

    // The function we actually call needs to be wrapped in try/catch and supplied with the API and other stuff
    return (note: Note): boolean => {
      try {
        // Passing in this tag as the this arg
        return classifierFunc.call(this, note, this.dataService.tags.progTagApi, _);
      }
      catch (err) {
        this.progTagError(err, note);
      }
    }
  }

  progTagError(err: Error, note: Note) {
    this._logger.error('Running programmatic tag on note ID', note.id, 'threw error:', err, err.stack, 'Tag prog function string:', this.progFuncString);

    // @TODO/prog

    // @TODO/modals
    alert('Hey there was an unhandled error running smart tags, leave this page up and show toby please.');

    // // closeModal may have been just called, so open up new modal in a different tick:
    // $timeout(function() {
    //   $s.m.confirm({
    //     bodyHTML: '<p>There was an error when running your function for tag "' + tag.name  + '":</p><pre>  ' + err + '</pre><p>Would you like to change this tag\'s function or revert to normal tag?</p>',
    //     okText: 'change function',
    //     okCb: function() {
    //       // closeModal may have been just called, so...
    //       $timeout(function() {
    //         $s.t.tagProgSettings(tag);
    //       }, 50);
    //     },
    //     cancelText: 'revert tag',
    //     cancelCb: function() {
    //       tag.prog = false;
    //       $s.t.tagUpdated(tag);
    //     },
    //     large: true,
    //   });
    // }, 50);
  }

  /** Given a noteId, find which childTag of this tag the note has, and return its "id" (or undefined if there's no child tag of this tag that the note has). */
  getChildTagIdForNoteId(noteId: string): string {
    if (! _.size(this.childTagDocs)) {
      return undefined;
    }

    let childTagId;

    _.each(this.childTagDocs, (docs, childTagName) => {
      if (_.includes(docs, noteId)) {
        childTagId = this.getChildTagId(childTagName);
        return false; // short-circuit _.each loop
      }
    });

    return childTagId;
  }
  /** Kind of lame, and evidence of poor data structure here, but to keep this consistent this is how we generate "id"s of child tags. */
  getChildTagId(childTagName: string): string {
    return this.id + ':' + childTagName;
  }
  getChildTagIds(): string[] {
    // Have to cooerce type with double any because bind messes up types.
    return _.map(_.keys(this.childTagDocs), this.getChildTagId.bind(this)) as any as string[];
  }

  /** Navigates to the tag details page for this tag, optionally to a sub-page within it. */
  goTo(subPage?: 'share' | 'smartness' | 'delete'): void {
    let path: string;

    if (subPage) {
      path = ['', 'tags', 'tag', this.parentTagId, this.name, subPage].join('/');
    }
    else {
      path = ['', 'tags', 'tag', this.parentTagId, this.name].join('/');
    }

    this.dataService.router.navigateByUrl(path);
  }

  /** Implemented in ChildTag to return not the child tag ID. */
  get parentTagId(): string {
    return this.id;
  }

  /** Returns array of Note instances that have this tag. */
  getNotes(): Note[] {
    return _(this.docs)
      .map((noteId) => this.dataService.notes.notes[noteId])
      .filter((note) => note) // remove falsey notes
      .value();
  }
}
